
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Assignment 2</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link rel="stylesheet" type="text/css" href="style.css" />
	</head>
	<body>

		<div>
  			<h2><span>SHIFTKoTS' VISUAL PORTFOLIO</span></h2>
  			<ul id="sliding-navigation">
    			<li class="sliding-element">
      				<h3>LINKS</h3>
    			</li>
    			<li class="sliding-element"><a href="https://www.behance.net/SHIFTKoTS">BEHANCE</a></li>
    			<li class="sliding-element"><a href="https://www.pinterest.com/shiftkots/">PINTEREST</a></li>
    			<li class="sliding-element"><a href="https://www.tumblr.com/blog/shiftkots">TUMBLR</a></li>
    			<li class="sliding-element"><a href="https://github.com/shiftkots">GITHUB</a></li>
    			<li class="sliding-element"><a href="https://www.facebook.com/"><i>FACEBOOK</i></a></li>
  			</ul>
		</div>
		<div id="container"></div>

		<script src="js/three.min.js"></script>

		<script src="js/Detector.js"></script>
		<script src="js/libs/stats.min.js"></script>

		<script src="js/jquery.js"></script>
		<script src="js/script.js"></script>

		<script id="vertexShader" type="x-shader/x-vertex">

			precision mediump float;
			precision mediump int;

			uniform mat4 modelViewMatrix; // optional
			uniform mat4 projectionMatrix; // optional

			attribute vec3 position;
			attribute vec4 color;

			varying vec3 vPosition;
			varying vec4 vColor;

			void main()	{

				vPosition = position;
				vColor = color;

				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			}

		</script>

		<script id="fragmentShader" type="x-shader/x-fragment">

			precision mediump float;
			precision mediump int;

			uniform float time;

			varying vec3 vPosition;
			varying vec4 vColor;

			void main()	{

				vec4 color = vec4( vColor );
				color.r += sin( vPosition.x * 8.0 + time ) * 0.7;

				gl_FragColor = color;

			}

		</script>

		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container, stats;

			var camera, scene, renderer;

			init();
			animate();

			function init() {

				container = document.getElementById( 'container' );

				camera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 1, 10 );
				camera.position.z = 0.5;

				scene = new THREE.Scene();

				// geometry

				var triangles = 300;

				var geometry = new THREE.BufferGeometry();

				var vertices = new THREE.BufferAttribute( new Float32Array( triangles * 3 * 3 ), 3 );

				for ( var i = 0; i < vertices.length; i ++ ) {

					vertices.setXYZ( i, Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.7 );

				}

				geometry.addAttribute( 'position', vertices );

				var colors = new THREE.BufferAttribute(new Float32Array( triangles * 3 * 3 ), 3 );

				for ( var i = 0; i < colors.length; i ++ ) {

					colors.setXYZW( i, Math.random(), Math.random(), Math.random(), Math.random() );

				}

				geometry.addAttribute( 'color', colors );

				// material

				var material = new THREE.RawShaderMaterial( {

					uniforms: {
						time: { type: "f", value: 1 }
					},
					vertexShader: document.getElementById( 'vertexShader' ).textContent,
					fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
					side: THREE.DoubleSide,
					transparent: true

				} );

				var mesh = new THREE.Mesh( geometry, material );
				scene.add( mesh );

				renderer = new THREE.WebGLRenderer();
				renderer.setClearColor( 000000 );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.
				top = '0px';
				container.appendChild( stats.domElement );

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize( event ) {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			function render() {

				var time = performance.now();

				var object = scene.children[ 0 ];

				object.rotation.x = time * 0.0005;
				object.material.uniforms.time.value = time * 0.005;

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>
